var xjst = require('xjst'),
    XJSTParser = xjst.XJSTParser,
    XJSTIdentity = xjst.XJSTIdentity,
    XJSTCompiler = xjst.XJSTCompiler,
    Jail = require('./jail').Jail,
    ometajs = require('ometajs'),
    BSJSParser = ometajs.grammars.BSJSParser,
    BSJSIdentity = ometajs.grammars.BSJSIdentity,
    BSJSTranslator = ometajs.grammars.BSJSTranslator;

var pp = require("zeHelpers").prettyPrint;

// TODO This checks if Mozilla AST node is literal. I maybe able to serialize a
// body using BSJSTranslator, parse with Esprima then use this function to
// check. Heavy and ugly but straightforward.
var isLiteral = xjst.utils.isLiteral;

ometa BEMHTMLParser <: BSJSParser {
  // isKeyword = :x ?(x === 'applyCtx')
  //           | ^isKeyword,

  bemMatch = bemBlock | bemElem | bemMod,

  bemVal = (letter | digit | '-')+:xs -> [#string, xs.join('')],
  bemVal = asgnExpr:e -> e,

  bemPredic :n = spaces seq(n):nn space+ -> nn,

  bemBlock = bemPredic('block'):n bemVal:v -> [#block, v],
  bemElem = bemPredic('elem') bemVal:v -> [#elem, v],
  bemModVal = iName:n ?(n === 'true' || n === 'false') -> [#get, n]
            | bemVal,
  bemMod = bemPredic('mod') bemVal:m space+ bemModVal:v -> [#blockMod, m, v],
  bemMod = bemPredic('elemMod') bemVal:m space+ bemModVal:v -> [#elemMod, m, v],

  bemCustom = asgnExpr:e -> [#xjst, e],

  bemhtmlSet = spaces <letter (letter | digit | '-' | '_')*>:nn
               &(spaces ('{' | ':' | ','))
               ?(!BEMHTMLParser._isPrimitive(nn))
               -> [ nn ],

  bemMatchAndSet = (bemMatch | bemhtmlSet | bemCustom),
  listBemMatchAndSet %(this.predicates = []) = bemMatchAndSet:t spaces
                     ( ',' spaces listBemMatchAndSet:ts -> {
                       [t, ts]
                     } | '{' spaces listBemMatchAndSet+:ts spaces '}'
                          spaces -> {
                            [t, ts]
                     } | ':' (asgnExpr:e -> [#begin, [#return, e]]
                             | stmt):c ','? ->
                       [t, [#body, this._jail.match(
                         c,
                         'topLevel',
                         ['_$' + (BEMHTMLParser._jailId++).toString(36)]
                       )]]
                     ):r -> {
                       if (this.predicates.length === 0) return r;
                       BEMHTMLParser._concatChildren(
                         [#xjst, this.predicates],
                         r
                       )
                     } | ^stmt:r -> [#stmt, r],

  topLevel = listBemMatchAndSet*:ts spaces end -> {
    // BEMHTMLParser._addElemPredic(BEMHTMLParser._dropAllSubs(ts))
    BEMHTMLParser._dropAllSubs(ts)
  }
}

BEMHTMLParser.prototype._jail = Jail;
BEMHTMLParser._jailId = 0;

BEMHTMLParser._transMode = function transMode(e) {
    function traverse(e) {
    if (e[0] !== 'binop' && e[1] !== ',') return [ e ];
    return [].concat(traverse(e[2]), traverse(e[3]));
  }

  return traverse(e).map(function (e) {
    if (e[0] !== 'string') return e;
    return [#set, [#getp, [#string, '_mode'], [#this]], e];
  }).reduce(function (acc, current) {
    return [#binop, ',', acc, current];
  });
};

BEMHTMLParser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

BEMHTMLParser._isPrimitive = function(name) {
  return BEMHTMLParser._primitives[name];
};

BEMHTMLParser._concatChildren = function(p, cs) {
  if (cs[0] !== 'sub') return [p].concat(cs);

  return [#sub, [].concat.apply([], cs[1].map(function(cs) {
    var cc = BEMHTMLParser._concatChildren(p, cs);
    return cc[0] === 'sub' ? cc[1] : [cc];
  }))];
};

BEMHTMLParser._dropAllSubs = function(ts) {
  return [].concat.apply([], ts.map(function(t) {
    return t[0] === 'sub' ? t[1] : [t];
  }));
};

BEMHTMLParser._addElemPredic = function(ts) {
  function isSafePredic(p) {
    switch (p[0]) {
      case 'get':
      case 'string':
      case 'number':
        return true;
      case 'getp':
        // Either this["some not elem property"],
        // or (some other host)["any property"]
        return p[2][0] === 'this' ?
            p[1][0] !== 'call' &&
            (p[1][0] !== 'string' || p[1][1] !== 'elem')
            :
            p[2][0] !== 'call';
      case 'unop':
        return isSafePredic(p[2]);
      case 'binop':
        return isSafePredic(p[2]) && isSafePredic(p[3]);
      default:
        return false;
    }
  }

  ts.forEach(function(t) {
    var isBlock,
        isNotElem;

    isBlock = t.some(function(p) {
      return p[0] === 'block';
    });

    if (!isBlock) return;

    isNotElem = t.every(function(p) {
      if (p[0] === 'elem' ||
          p[0] === 'xjst' && !isSafePredic(p[1])) {
        return false;
      }

      return true;
    });

    if (!isNotElem) return;

    t.unshift([
      'xjst',
      ['unop', '!', ['getp', ['string', 'elem'], ['this']]]
    ]);
  });
  return ts;
};

var DEBUG = false;

ometa BEMHTMLIdentity <: BSJSIdentity {
  debug :what :text = ?(DEBUG) {pp(what, {prompt: "" + text});}
    | -> true,

  bhPredic = [#block :e] -> [#block, e],
  bhPredic = [#blockMod :m :v] -> [#blockMod, m, v],
  bhPredic = [#elem :e] -> [#elem, e],
  bhPredic = [#elemMod :m :v] -> [#elemMod, m, v],
  bhPredic = [#xjst :e] -> [#match, e],
  bhPredic = [#match :e] -> [#match, e],

  bhPredic = [#std :m] -> [#std, m],
  bhPredic = [#mode :m] -> [#mode, m],
  bhPredic = [ :m ] -> [this.isStandardMode(m)? #std: #mode, m],

  // TODO should I unshift #sub and #dot tags instead of concatenating em?
  bhBody = [#body :b] -> [#body, b],
  subBlock = [#sub :ts] -> [#sub, ts],
  subBlock = [subTemplate+:ts] debug(ts, "subBlock out") -> [#sub, ts],
  subMethod = [#dot :ts] -> [#dot, ts],
  subMethod = subTemplate:ts debug(ts, "subMethod out") -> [#dot, ts],

  subTemplate = [bhPredic:ps    debug(ps, "sub bhPredicate+")
                 (bhBody:b      debug(b, "sub bhBody") -> b
                  | subBlock:s  debug(s, "sub subBlock") -> s
                  | subMethod:m debug(m, "sub subMethod") -> m
                 ):ts] -> [ps, ts],

  bhTemplate = [#template :t] -> t,
  bhTemplate = [bhPredic:ps     debug(ps, "bhPredicate+")
                (bhBody:b       debug(b, "bhBody") -> b
                 | subMethod:m  debug(m, "subMethod") -> m
                 | subBlock:s   debug(s, "subBlock") -> s
                ):ts]           debug(ps.concat(['...']), "bhTemplate matched") -> [ ps, ts ]
    | [#stmt anything]:r -> r,

  topLevel = [bhTemplate+:ts] -> ts.map(function (t) { return [#template, t];}),
  topLevel = bhTemplate:t -> [t],
  topLevel = end -> []
}

BEMHTMLIdentity.prototype.isStandardMode = function isStandardMode(m) {
  var modes = ['tag', 'attrs', 'content', 'default', 'js', 'mix', 'bem', 'jsAttr', 'cls'];
  return modes.some(function (curr) { return curr === m; });
};

BEMHTMLIdentity.cons = function cons(arr) {
  return arr.reduce(function(prev, curr) {
    return ['binop', '&&', prev, curr];
  });
};

ometa BEMHTMLToJS <: BSJSTranslator {
  block trans:e -> ('block(' + e + ')' ),
  blockMod trans:m trans:v -> ('mod(' + e + ',' + v + ')' ),
  elem trans:e -> ('elem(' + e + ')' ),
  elemMod trans:m trans:v -> ('elemMod(' + e + ',' + v + ')' ),
  match trans:e -> ('match(' + e + ')' ),
  body trans:b -> ('(function() { ' + b + '})'),

  std :m -> (m + '()'),
  mode :m -> ('mode(' + m + ')'),

  subStmt = trans*:s -> s.join(''),
  sbody = [subStmt*:ss] -> ss.join(', '),
  sub [sbody:s] -> '(' + s + ')',

  dot [trans*:e] -> '.' + e.join(''),

  tbody = [ trans*:e ] -> e.join(''),

  template = [#template tbody:t] -> t,

  item = template:r -> r
       | [#stmt [#return anything]] -> ''
       | [#stmt
           [#unop '!'
             [#call [#func 'oninit' anything trans:body] anything*]
           ]
         ] -> 'oninit(function(exports) ' + body + ')'
       | [#stmt trans:r] -> r,

  topLevel = [ item*:rs ] -> rs.join(';\n')
}
