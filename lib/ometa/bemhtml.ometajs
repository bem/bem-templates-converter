var ometajs = require("ometajs"),
    BSJSParser = ometajs.grammars.BSJSParser,
    BSJSIdentity = ometajs.grammars.BSJSIdentity,
    BSJSTranslator = ometajs.grammars.BSJSTranslator,
    esprima = require("esprima"),
    assert = require("assert"),
    // HACK having RegExp I need in this file breaks ometa
    repQ = require("./hack").repQ;

function toMozNode(ast) {
  var code = BSJSTranslator.match(ast, 'stmt'),
      mozAst = esprima.parse(code),
      body = mozAst.body;
  assert(body.length === 1);
  return body[0].expression;
}

function isLiteral(ast) {
  if (ast.type === 'Literal')
    return true;

  if (ast.type === 'Identifier' && ast.name === 'undefined')
    return true;

  if (ast.type === 'ObjectExpression') {
    return ast.properties.every(function(prop) {
      return isLiteral(prop.value);
    });
  }

  if (ast.type === 'ArrayExpression') {
    return ast.elements.every(function(elem) {
      return isLiteral(elem);
    });
  }

  return false;
};


ometa BEMHTMLParser <: BSJSParser {
  isKeyword :x = ?(BSJSParser._isKeyword(x) || x === 'local'),

  primExprHd = "local" "(" expr:a ")" asgnExpr:b -> [#localKwd, a, b]
    | ^primExprHd,

  stmt = "local" "(" expr:a ")" stmt:b  -> [#localKwd, a, b]
    | ^stmt,

  bemMatch = bemBlock | bemElem | bemMod,

  bemVal = (letter | digit | '-')+:xs -> [#string, xs.join('')],
  bemVal = asgnExpr:e -> e,

  bemPredic :n = spaces seq(n):nn space+ -> nn,

  bemBlock = bemPredic('block'):n bemVal:v -> [#block, v],
  bemElem = bemPredic('elem') bemVal:v -> [#elem, v],
  bemModVal = iName:n ?(n === 'true' || n === 'false') -> [#get, n]
            | bemVal,
  bemMod = bemPredic('mod') bemVal:m space+ bemModVal:v -> [#blockMod, m, v],
  bemMod = bemPredic('elemMod') bemVal:m space+ bemModVal:v -> [#elemMod, m, v],

  bemCustom = asgnExpr:e -> [#xjst, e],

  bemhtmlSet = spaces <letter (letter | digit | '-' | '_')*>:nn
               &(spaces ('{' | ':' | ','))
               ?(!BEMHTMLParser._isPrimitive(nn))
               -> [ nn ],

  bemMatchAndSet = (bemMatch | bemhtmlSet | bemCustom),
  listBemMatchAndSet %(this.predicates = []) = bemMatchAndSet:t spaces
                     ( ',' spaces listBemMatchAndSet:ts -> {
                       [t, ts]
                     } | '{' spaces listBemMatchAndSet+:ts spaces '}'
                          spaces -> {
                            [t, ts]
                     } | ':' (asgnExpr:e -> isLiteral(toMozNode(e))?
                              [#literal, e]:
                              [#begin, [#return, e]]
                             | stmt):c ','? ->
                       [t, [#body, c]]
                     ):r -> {
                       if (this.predicates.length === 0) return r;
                       BEMHTMLParser._concatChildren(
                         [#xjst, this.predicates],
                         r
                       )
                     } | ^stmt:r -> [#stmt, r],

  topLevel = listBemMatchAndSet*:ts spaces end -> {
    BEMHTMLParser._dropAllSubs(ts)
  }
}

BEMHTMLParser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

BEMHTMLParser._isPrimitive = function(name) {
  return BEMHTMLParser._primitives[name];
};

BEMHTMLParser._concatChildren = function(p, cs) {
  if (cs[0] !== 'sub') return [p].concat(cs);

  return [#sub, [].concat.apply([], cs[1].map(function(cs) {
    var cc = BEMHTMLParser._concatChildren(p, cs);
    return cc[0] === 'sub' ? cc[1] : [cc];
  }))];
};

BEMHTMLParser._dropAllSubs = function(ts) {
  return [].concat.apply([], ts.map(function(t) {
    return t[0] === 'sub' ? t[1] : [t];
  }));
};

ometa Binding <: BSJSTranslator {
  getp = [#string :p] [#this] trans([#get, p])
    | ^getp
}

var DEBUG = false;

ometa BEMHTMLIdentity <: BSJSIdentity {
  debug :what :text = ?(DEBUG) {pp(what, {prompt: "" + text});}
    | -> true,

  bhPredic = [#block :e] -> [#block, e],
  bhPredic = [#blockMod :m :v] -> [#blockMod, m, v],
  bhPredic = [#elem :e] -> [#elem, e],
  bhPredic = [#elemMod :m :v] -> [#elemMod, m, v],
  bhPredic = [#xjst :e] -> [#match, e],
  bhPredic = [#match :e] -> [#match, e],

  bhPredic = [#std :m] -> [#std, m],
  bhPredic = [#mode :m] -> [#mode, m],
  maybeDef = #default -> #def,
  maybeDef = :m -> m,
  bhPredic = [ maybeDef:m ] -> this.getMode(m),

  // handle apply and applyNext args specially
  call = [#get (#applyNext | #apply)]:fn applyArg+:bindings
    -> [#call, fn, [].concat.apply([#json], bindings)]
    | ^call,
  applyArg ([#set :prop :val] {Binding.match(prop, 'stmt')}:b -> [[#binding, b, val]]
            | [#json anything*]:j -> { j.shift(); return j }
            | [#string anything]:m -> [[#binding, #_mode, m]]
           ),

  larg = [#binop ',' larg:l larg:r] -> [].concat.apply([], [l, r]),
  larg = :s -> [s],
  largs = [applyArg*:bindings] ->  {
    bindings.length?
      [[].concat.apply([#json], bindings)]:
      bindings
  },
  localKwd larg:args largs(args):as :body -> [#localKwd,
                                              [#call, [#get, #local]].concat(as),
                                              body],

  wrapBody = [#literal :b] -> [#literal, b]
    | trans:b -> [#func, null, [], b],

  bhBody = [#body :b] trans([#wrapBody, b]):wb -> [#body, wb],
  subBlock = [#sub :ts] -> [#sub, ts],
  subBlock = [subTemplate+:ts] debug(ts, "subBlock out") -> [#sub, ts],
  subMethod = [#dot :ts] -> [#dot, ts],
  subMethod = subTemplate:ts debug(ts, "subMethod out") -> [#dot, ts],

  subTemplate = [bhPredic:ps    debug(ps, "sub bhPredicate+")
                 (bhBody:b      debug(b, "sub bhBody") -> b
                  | subBlock:s  debug(s, "sub subBlock") -> s
                  | subMethod:m debug(m, "sub subMethod") -> m
                 ):ts] -> [ps, ts],

  bhTemplate = [#template :t] -> [#template, t],
  bhTemplate = [bhPredic:ps     debug(ps, "bhPredicate+")
                (bhBody:b       debug(b, "bhBody") -> b
                 | subMethod:m  debug(m, "subMethod") -> m
                 | subBlock:s   debug(s, "subBlock") -> s
                ):ts]           debug(ps.concat(['...']), "bhTemplate matched") -> [#template, [ ps, ts ]]
    | [#stmt anything]:r -> r,

  topLevel = [bhTemplate+:ts] -> ts,
  topLevel = bhTemplate:t -> [t],
  topLevel = end -> []
}

BEMHTMLIdentity.prototype.getMode = function getMode(m) {
  var modes = ['tag', 'attrs', 'content', 'def', 'js', 'mix', 'bem', 'jsAttr', 'cls'];
  return modes.some(function (curr) { return curr === m; })?
    ['std', m]:
    ['mode', JSON.stringify(m)];
};

ometa BEMHTMLToJS <: BSJSTranslator {
  // HACK wrapping strings in single quotes
  // HACK avoid quoting property names that are valid identifiers
  binding  :name ?(this.isName(name)) trans:val -> (name + ': ' + val),
  binding  :name  trans:val -> (repQ(name) + ': ' + val),
  string :s -> repQ(s + ''),

  // drop empty else branch
  if trans:cond curlyTrans:t ([#get #undefined] -> ('if(' + cond + ')' + t)
                              | curlyTrans:e    -> ('if(' + cond + ')' + t + 'else' + e)),

  block trans:e -> ('block(' + e + ')' ),
  blockMod trans:m trans:v -> ('mod(' + m + ',' + v + ')' ),
  elem trans:e -> ('elem(' + e + ')' ),
  elemMod trans:m trans:v -> ('elemMod(' + m + ',' + v + ')' ),
  match trans:e -> ('match(' + e + ')' ),
  localKwd trans:c trans:b -> (c + '(function() {' + b + '})'),

  literalBody = [#literal trans:b] -> b,
  body (literalBody:b -> '(' + b + ')'
        | trans:b -> ('(' + b + ')')),

  std :m -> (m + '()'),
  mode :m -> ('mode(' + m + ')'),

  subStmt = trans*:s -> s.join(''),
  sbody = [subStmt*:ss] -> ss.join(','),
  sub [sbody*:s] -> '(\n' + s.join(',\n') + '\n)',

  dot [trans*:e] -> '.' + e.join(''),

  tbody = [ trans*:e ] -> e.join(''),

  template = [#template tbody:t] -> t,

  item = template:r -> r
       | [#stmt [#return anything]] -> ''
       | [#stmt
           [#unop '!'
             [#call [#func 'oninit' anything trans:body] anything*]
           ]
         ]  -> 'oninit(function(exports) {' + body + '})'
       | [#stmt trans:r] -> r,

  topLevel = [ item*:rs ] -> rs.join(';\n\n')
}

BEMHTMLToJS.prototype.isName = function isName(s) {
  var re = /^[a-z$_][a-z0-9$_]*$/i;
  return re.test(s);
};
