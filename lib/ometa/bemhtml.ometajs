var ometajs = require("ometajs"),
    BSJSParser = ometajs.grammars.BSJSParser,
    BSJSIdentity = ometajs.grammars.BSJSIdentity,
    BSJSTranslator = ometajs.grammars.BSJSTranslator,
    pp = require("zeHelpers").prettyPrint,
    esprima = require("esprima"),
    assert = require("assert");

function toMozNode(ast) {
  var code = BSJSTranslator.match(ast, 'stmt'),
      mozAst = esprima.parse(code),
      body = mozAst.body;
  assert(body.length === 1);
  return body[0].expression;
}

// TODO This checks if Mozilla AST node is literal. Only appears in non-ometa
// version of xjst! If I can drop Jail, then I could depend on non-ometa xjst
// and avoid this copy-pasta.
function isLiteral(ast) {
  if (ast.type === 'Literal')
    return true;

  if (ast.type === 'Identifier' && ast.name === 'undefined')
    return true;

  if (ast.type === 'ObjectExpression') {
    return ast.properties.every(function(prop) {
      return isLiteral(prop.value);
    });
  }

  if (ast.type === 'ArrayExpression') {
    return ast.elements.every(function(elem) {
      return isLiteral(elem);
    });
  }

  return false;
};


ometa BEMHTMLParser <: BSJSParser {

  bemMatch = bemBlock | bemElem | bemMod,

  bemVal = (letter | digit | '-')+:xs -> [#string, xs.join('')],
  bemVal = asgnExpr:e -> e,

  bemPredic :n = spaces seq(n):nn space+ -> nn,

  bemBlock = bemPredic('block'):n bemVal:v -> [#block, v],
  bemElem = bemPredic('elem') bemVal:v -> [#elem, v],
  bemModVal = iName:n ?(n === 'true' || n === 'false') -> [#get, n]
            | bemVal,
  bemMod = bemPredic('mod') bemVal:m space+ bemModVal:v -> [#blockMod, m, v],
  bemMod = bemPredic('elemMod') bemVal:m space+ bemModVal:v -> [#elemMod, m, v],

  bemCustom = asgnExpr:e -> [#xjst, e],

  bemhtmlSet = spaces <letter (letter | digit | '-' | '_')*>:nn
               &(spaces ('{' | ':' | ','))
               ?(!BEMHTMLParser._isPrimitive(nn))
               -> [ nn ],

  bemMatchAndSet = (bemMatch | bemhtmlSet | bemCustom),
  listBemMatchAndSet %(this.predicates = []) = bemMatchAndSet:t spaces
                     ( ',' spaces listBemMatchAndSet:ts -> {
                       [t, ts]
                     } | '{' spaces listBemMatchAndSet+:ts spaces '}'
                          spaces -> {
                            [t, ts]
                     } | ':' (asgnExpr:e -> isLiteral(toMozNode(e))?
                              [#literal, e]:
                              [#begin, [#return, e]]
                             | stmt):c ','? ->
                       [t, [#body, c]]
                     ):r -> {
                       if (this.predicates.length === 0) return r;
                       BEMHTMLParser._concatChildren(
                         [#xjst, this.predicates],
                         r
                       )
                     } | ^stmt:r -> [#stmt, r],

  topLevel = listBemMatchAndSet*:ts spaces end -> {
    BEMHTMLParser._dropAllSubs(ts)
  }
}

BEMHTMLParser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

BEMHTMLParser._isPrimitive = function(name) {
  return BEMHTMLParser._primitives[name];
};

BEMHTMLParser._concatChildren = function(p, cs) {
  if (cs[0] !== 'sub') return [p].concat(cs);

  return [#sub, [].concat.apply([], cs[1].map(function(cs) {
    var cc = BEMHTMLParser._concatChildren(p, cs);
    return cc[0] === 'sub' ? cc[1] : [cc];
  }))];
};

BEMHTMLParser._dropAllSubs = function(ts) {
  return [].concat.apply([], ts.map(function(t) {
    return t[0] === 'sub' ? t[1] : [t];
  }));
};

ometa Binding <: BSJSTranslator {
  getp = [#string :p] [#this] trans([#get, p])
    | ^getp
}

var DEBUG = false;

ometa BEMHTMLIdentity <: BSJSIdentity {
  debug :what :text = ?(DEBUG) {pp(what, {prompt: "" + text});}
    | -> true,

  bhPredic = [#block :e] -> [#block, e],
  bhPredic = [#blockMod :m :v] -> [#blockMod, m, v],
  bhPredic = [#elem :e] -> [#elem, e],
  bhPredic = [#elemMod :m :v] -> [#elemMod, m, v],
  bhPredic = [#xjst :e] -> [#match, e],
  bhPredic = [#match :e] -> [#match, e],

  bhPredic = [#std :m] -> [#std, m],
  bhPredic = [#mode :m] -> [#mode, m],
  maybeDef = #default -> #def,
  maybeDef = :m -> m,
  bhPredic = [ maybeDef:m ] -> this.getMode(m),

  wrapBody = [#literal :b] -> [#literal, b]
    | trans:b -> [#func, '', [], b],
  assgn [#set :prop :val] {Binding.match(prop, 'stmt')}:b -> [#binding, b, val],
  call = [#get #applyNext]:fn assgn+:bindings
    -> [#call, fn, [#json].concat(bindings)]
    | ^call,
  bhBody = [#body :b] trans([#wrapBody, b]):wb -> [#body, wb],
  subBlock = [#sub :ts] -> [#sub, ts],
  subBlock = [subTemplate+:ts] debug(ts, "subBlock out") -> [#sub, ts],
  subMethod = [#dot :ts] -> [#dot, ts],
  subMethod = subTemplate:ts debug(ts, "subMethod out") -> [#dot, ts],

  subTemplate = [bhPredic:ps    debug(ps, "sub bhPredicate+")
                 (bhBody:b      debug(b, "sub bhBody") -> b
                  | subBlock:s  debug(s, "sub subBlock") -> s
                  | subMethod:m debug(m, "sub subMethod") -> m
                 ):ts] -> [ps, ts],

  bhTemplate = [#template :t] -> t,
  bhTemplate = [bhPredic:ps     debug(ps, "bhPredicate+")
                (bhBody:b       debug(b, "bhBody") -> b
                 | subMethod:m  debug(m, "subMethod") -> m
                 | subBlock:s   debug(s, "subBlock") -> s
                ):ts]           debug(ps.concat(['...']), "bhTemplate matched") -> [ ps, ts ]
    | [#stmt anything]:r -> r,

  topLevel = [bhTemplate+:ts] -> ts.map(function (t) { return [#template, t];}),
  topLevel = bhTemplate:t -> [t],
  topLevel = end -> []
}

BEMHTMLIdentity.prototype.getMode = function getMode(m) {
  var modes = ['tag', 'attrs', 'content', 'def', 'js', 'mix', 'bem', 'jsAttr', 'cls'];
  return modes.some(function (curr) { return curr === m; })?
    ['std', m]:
    ['mode', JSON.stringify(m)];
};

ometa BEMHTMLToJS <: BSJSTranslator {
  block trans:e -> ('block(' + e + ')' ),
  blockMod trans:m trans:v -> ('mod(' + m + ',' + v + ')' ),
  elem trans:e -> ('elem(' + e + ')' ),
  elemMod trans:m trans:v -> ('elemMod(' + m + ',' + v + ')' ),
  match trans:e -> ('match(' + e + ')' ),

  literalBody = [#literal trans:b] -> b,
  body (literalBody:b -> '(' + b + ')'
        | trans:b -> ('(' + b + ')')),

  std :m -> (m + '()'),
  mode :m -> ('mode(' + m + ')'),

  subStmt = trans*:s -> s.join(''),
  sbody = [subStmt*:ss] -> ss.join(', '),
  sub [sbody*:s] -> '(' + s + ')',

  dot [trans*:e] -> '.' + e.join(''),

  tbody = [ trans*:e ] -> e.join(''),

  template = [#template tbody:t] -> t,

  item = template:r -> r
       | [#stmt [#return anything]] -> ''
       | [#stmt
           [#unop '!'
             [#call [#func 'oninit' anything trans:body] anything*]
           ]
         ] -> 'oninit(function(exports) ' + body + ')'
       | [#stmt trans:r] -> r,

  topLevel = [ item*:rs ] -> rs.join(';\n')
}
