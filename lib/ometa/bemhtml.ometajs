var ometajs = require("ometajs"),
    BSJSParser = ometajs.grammars.BSJSParser,
    BSJSIdentity = ometajs.grammars.BSJSIdentity,
    BSJSTranslator = ometajs.grammars.BSJSTranslator,
    esprima = require("esprima"),
    assert = require("assert"),
    // HACK having RegExp I need in this file breaks ometa
    repQ = require("./hack").repQ;

function toMozNode(ast) {
  var code = BSJSTranslator.match(ast, 'stmt'),
      mozAst = esprima.parse(code),
      body = mozAst.body;
  assert(body.length === 1);
  return body[0].expression;
}

function isLiteral(ast) {
  if (ast.type === 'Literal')
    return true;

  if (ast.type === 'Identifier' && ast.name === 'undefined')
    return true;

  if (ast.type === 'ObjectExpression') {
    return ast.properties.every(function(prop) {
      return isLiteral(prop.value);
    });
  }

  if (ast.type === 'ArrayExpression') {
    return ast.elements.every(function(elem) {
      return isLiteral(elem);
    });
  }

  return false;
};


ometa BEMHTMLParser <: BSJSParser {
  isKeyword :x = ?(BSJSParser._isKeyword(x) || x === 'local'),

  primExprHd = "local" "(" expr:a ")" asgnExpr:b -> [#localKwd, a, b]
    | ^primExprHd,

  stmt = "local" "(" expr:a ")" stmt:b  -> [#localKwd, a, b]
    | ^stmt,

  bemMatch = bemBlock | bemElem | bemMod,

  bemVal = (letter | digit | '-')+:xs -> [#string, xs.join('')],
  bemVal = asgnExpr:e -> e,

  bemPredic :n = spaces seq(n):nn space+ -> nn,

  bemBlock = bemPredic('block'):n bemVal:v -> [#block, v],
  bemElem = bemPredic('elem') bemVal:v -> [#elem, v],
  bemModVal = iName:n ?(n === 'true' || n === 'false') -> [#get, n]
            | bemVal,
  bemMod = bemPredic('mod') bemVal:m space+ bemModVal:v -> [#blockMod, m, v],
  bemMod = bemPredic('elemMod') bemVal:m space+ bemModVal:v -> [#elemMod, m, v],

  bemCustom = asgnExpr:e -> [#xjst, e],

  bemhtmlSet = spaces <letter (letter | digit | '-' | '_')*>:nn
               &(spaces ('{' | ':' | ','))
               ?(!BEMHTMLParser._isPrimitive(nn))
               -> [ nn ],

  bemMatchAndSet = (bemMatch | bemhtmlSet | bemCustom),
  listBemMatchAndSet %(this.predicates = []) = bemMatchAndSet:t spaces
                     ( ',' spaces listBemMatchAndSet:ts -> {
                       [t, ts]
                     } | '{' spaces listBemMatchAndSet+:ts spaces '}'
                          spaces -> {
                            [t, ts]
                     } | ':' (asgnExpr:e -> isLiteral(toMozNode(e))?
                              [#literal, e]:
                              [#begin, [#return, e]]
                             | stmt):c ','? ->
                       [t, [#body, c]]
                     ):r -> {
                       if (this.predicates.length === 0) return r;
                       BEMHTMLParser._concatChildren(
                         [#xjst, this.predicates],
                         r
                       )
                     } | ^stmt:r -> [#stmt, r],

  topLevel = listBemMatchAndSet*:ts spaces end -> {
    BEMHTMLParser._dropAllSubs(ts)
  }
}

BEMHTMLParser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

BEMHTMLParser._isPrimitive = function(name) {
  return BEMHTMLParser._primitives[name];
};

BEMHTMLParser._concatChildren = function(p, cs) {
  if (cs[0] !== 'sub') return [p].concat(cs);

  return [#sub, [].concat.apply([], cs[1].map(function(cs) {
    var cc = BEMHTMLParser._concatChildren(p, cs);
    return cc[0] === 'sub' ? cc[1] : [cc];
  }))];
};

BEMHTMLParser._dropAllSubs = function(ts) {
  return [].concat.apply([], ts.map(function(t) {
    return t[0] === 'sub' ? t[1] : [t];
  }));
};

ometa Binding <: BSJSTranslator {
  getp = [#string :p] [#this] trans([#get, p])
    | ^getp
}

var DEBUG = false;

function transformApply(fn, bindings) {
  var stringMode = [];
  // flatten bindings and filter any string-arg out
  var bs = [].concat.apply([], bindings).filter(function (b) {
    if (b[0] === #binding) return true;
    if (b[0] === #string) {
      stringMode.push(b);
      return false;
    }
  });
  // create an objarg
  bs.unshift(#json);
  // string-arg comes before the objarg
  return [#call, fn].concat(stringMode, [bs]) ;
};

ometa BEMHTMLTransformer <: BSJSIdentity {
  debug :what :text = ?(DEBUG) {pp(what, {prompt: "" + text});}
    | -> true,

  bhPredic = [#block :e] -> [#block, e],
  bhPredic = [#blockMod :m :v] -> [#blockMod, m, v],
  bhPredic = [#elem :e] -> [#elem, e],
  bhPredic = [#elemMod :m :v] -> [#elemMod, m, v],

  // Wrap custom predicates in a func
  bhPredic = [#xjst :e] -> [#match,
                            [#func, null, [],
                             [#begin, [#stmt, [#return, e]]]]],
  bhPredic = [#match :e] -> [#match, e],

  bhPredic = [#std :m] -> [#std, m],
  bhPredic = [#mode :m] -> [#mode, m],
  maybeDef = #default -> #def,
  maybeDef = :m -> m,
  bhPredic = [ maybeDef:m ] -> this.getMode(m),

  // force return apply and friends
  returnApply = [ #call [#get (#applyNext
                               | #apply
                               | #applyCtx) anything*]]:a -> [#return, a]
    | anything:a -> a,
  stmt trans:s returnApply(s):a -> [#stmt, a],

  // NOTE handle apply, applyNext, local args specially, preserve string-arg
  // passed to apply, contract the rest onto objarg
  call = [#get (#applyNext | #apply)]:fn applyArg+:bindings
    -> transformApply(fn, bindings)
    | ^call,
  applyArg ([#set :prop :val] {Binding.match(prop, 'stmt')}:b -> [[#binding, b, val]]
            | [#json anything*]:j -> { j.shift(); return j }
            | [#string anything]:m -> [m]
           ),

  larg = [#binop ',' larg:l larg:r] -> [].concat.apply([], [l, r]),
  larg = :s -> [s],
  largs = [applyArg*:bindings] ->  {
    bindings.length?
      [[].concat.apply([#json], bindings)]:
      bindings
  },
  localKwd larg:args largs(args):as :body -> [#localKwd,
                                              [#call, [#get, #local]].concat(as),
                                              body],

  wrapBody = [#literal :b] -> [#literal, b]
    | trans:b -> [#func, null, [], b],

  bhBody = [#body :b] trans([#wrapBody, b]):wb -> [#body, wb],
  subBlock = [#sub :ts] -> [#sub, ts],
  subBlock = [subTemplate+:ts] debug(ts, "subBlock out") -> (ts.length === 1)?
    // NOTE collapse nesting with single sub-template
    [#dot, ts[0]]:
    [#sub, ts],
  subMethod = [#dot :ts] -> [#dot, ts],
  subMethod = subTemplate:ts debug(ts, "subMethod out") -> [#dot, ts],

  subTemplate = [bhPredic:ps    debug(ps, "sub bhPredicate+")
                 (bhBody:b      debug(b, "sub bhBody") -> b
                  | subBlock:s  debug(s, "sub subBlock") -> s
                  | subMethod:m debug(m, "sub subMethod") -> m
                 ):ts] -> [ps, ts],

  bhTemplate = [#template :t] -> [#template, t],
  bhTemplate = [bhPredic:ps     debug(ps, "bhPredicate+")
                (bhBody:b       debug(b, "bhBody") -> b
                 | subMethod:m  debug(m, "subMethod") -> m
                 | subBlock:s   debug(s, "subBlock") -> s
                ):ts]           debug(ps.concat(['...']), "bhTemplate matched") -> [#template, [ ps, ts ]]
    | [#stmt anything]:r -> r,

  topLevel = [bhTemplate+:ts] -> ts,
  topLevel = bhTemplate:t -> [t],
  topLevel = end -> []
}

BEMHTMLTransformer.prototype.getMode = function getMode(m) {
  var modes = ['tag', 'attrs', 'content', 'def', 'js', 'mix', 'bem', 'jsAttr', 'cls'];
  return modes.some(function (curr) { return curr === m; })?
    ['std', m]:
    ['mode', JSON.stringify(m)];
};

function hasParens(e) {
  try {
    if (BEMHTMLParser.matchAll(e, #primExprHd)[0] === #parens) return true;
  } catch (e) {
  }
  return false;
}

ometa BEMHTMLToJS <: BSJSTranslator {
  // HACK to drop empty statemets
  curlyTrans = [#begin curlyTrans:r] -> r
    | [#begin trans*:rs] -> ('{'
                             + rs.filter(function (e) { return e !== '';}).join(';') + ';'
                             + '}'
                            )
    | trans:r               -> ('{' + r + ';' + '}'),

  stmt = [#get #undefined] -> (''),
  stmt ^stmt,

  // HACK parenthesized binop often return parens expr. Do not wrap in extra
  // parens when this happens.
  // TODO (indutny) fix this in ometa, it insists on wrapping binops in parens
  parens  trans:e (?hasParens(e) -> e
                   | -> ('(' + e + ')')),

  // NOTE maybe quote object keys
  binding :name ?(!this._options.quote_keys
                  && this.isName(name)) trans:val -> (name + ': ' + val),
  binding  :name trans:val -> (repQ(name, this._options.quotes) + ': ' + val),
  // NOTE maybe prefer double quotes
  string :s -> repQ(s + '', this._options.quotes),

  // NOTE drop empty else branch
  if trans:cond curlyTrans:t ([#get #undefined] -> ('if(' + cond + ')' + t)
                              | curlyTrans:e    -> ('if(' + cond + ')' + t + 'else' + e)),

  block trans:e                    -> ('block(' + e + ')' ),
  blockMod trans:m trans:v         -> ('mod(' + m + ',' + v + ')' ),
  elem trans:e                     -> ('elem(' + e + ')' ),
  elemMod trans:m trans:v          -> ('elemMod(' + m + ',' + v + ')' ),
  match trans:e                    -> ('match(' + e + ')' ),
  localKwd trans:c curlyTrans:b         -> (c + '(function()' + b + ')'),

  literalBody = [#literal trans:b] -> b,
  body (literalBody:b              -> '(' + b + ')'
        | trans:b                  -> ('(' + b + ')')),

  std :m   -> (m + '()'),
  mode :m  -> ('mode(' + repQ(JSON.parse(m), this._options.quotes) + ')'),

  subStmt = trans*:s               -> s.join(''),
  sbody = [subStmt*:ss]            -> ss.join(','),
  sub [sbody*:s]                   -> '(\n' + s.join(',\n') + '\n)',

  dot [trans*:e]                   -> '.' + e.join(''),

  tbody = [ trans*:e ]             -> e.join(''),

  template = [#template tbody:t]   -> t,

  item = template:r -> r
       | [#stmt [#return anything]] -> ''
       | [#stmt
           [#unop '!'
             [#call [#func 'oninit' anything curlyTrans:body] anything*]
           ]
         ] -> 'oninit(function(exports) ' + body + ')'
       | [#stmt trans:r] -> r,

  topLevel = [ item*:rs ] -> (rs.join(';\n\n') + ';')
}

BEMHTMLToJS.prototype.isName = function isName(s) {
  var re = /^[a-z$_][a-z0-9$_]*$/i;
  return re.test(s);
};
