var ometajs = require("ometajs"),
    esprima = require("esprima"),
    assert = require("assert"),
    krasota = require("krasota"),
    KParser = krasota.KrasotaJSParser,
    KIdentity = krasota.KrasotaJSIdentity,
    KSerializer = krasota.KrasotaJSSerializer;

var pp = require("zeHelpers").prettyPrint;

function toMozNode(code) {
  var mozAst = esprima.parse(code);
  var body = mozAst.body;
  assert(body.length === 1);
  return body[0].expression;
};

function isLiteral(ast) {
  // TODO exprStmt rule is unlikely to work for all cases
  try {
    // HACK to avoid extending KrasotaJSSerializer with bem-xjst non-terminals
    // like applyNext etc. When rule is missing it works but still prints to
    // stderr, see https://github.com/veged/ometa-js/issues/30
    var code = KSerializer._flatjoin(KSerializer.match(ast, 'exprStmt'));
  } catch (e) {
    return false;
  }

  if (ast[0] === ('obj')) {
    code = '(' + code + ')';
  }
  return checkLiteral(toMozNode(code));
}

function checkLiteral(ast) {
  if (ast.type === 'Literal')
    return true;

  if (ast.type === 'Identifier' && ast.name === 'undefined')
    return true;

  if (ast.type === 'ObjectExpression') {
    return ast.properties.every(function(prop) {
      return checkLiteral(prop.value);
    });
  }

  if (ast.type === 'ArrayExpression') {
    return ast.elements.every(function(elem) {
      return checkLiteral(elem);
    });
  }

  return false;
};

function toStmt(s, se, sc1, sc2) {
  return [ 'stmt',
           sc1? sc1: [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
           s,
           se? se: [ 'stmtEnd', [ 'spacesAndComments', [] ] ],
           sc2? sc2: [ 'spacesAndComments', [] ] ]
}

function toReturn(s, sc1, sc2) {
  return [ 'returnStmt',
           sc1? sc1: [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
           s,
           sc2? sc2: [ 'spacesAndComments', [] ] ]
}

ometa Parser <: KParser {

  topLevel = [(bemStmts | sc):c] -> c
    | ^topLevel,

  isXjstKeyword :x = ?(x === 'local' || x === 'apply' || x === 'applyNext' || x === 'applyCtx'),
  xjstKeyword :k = iName:kk isXjstKeyword(kk) ?(!k || k == kk) -> [#xjstKeyword, kk],

  // TODO stmt instead of a block here?
  localStmt = xjstKeyword(#local) sc:sc1 args:as sc:sc2 block:c -> [#local, sc1, as, sc2, c],
  localExpr = localStmt,

  applyExpr :k = xjstKeyword(k) sc:sc1 args:as -> [k, sc1, as],
  xjst = applyExpr(#apply)
    | applyExpr(#applyNext)
    | applyExpr(#applyCtx)
    | localExpr,

  // NOTE adding a case to expr rule is bad idea, cause then comalist
  // expressions like (bracketed expr) with applyCtx and friends fail. This
  // needs testing but seems more solid.
  leftExpr = xjst | localStmt | callExpr | newExpr,

  stmtContent = localStmt
    | ^stmtContent,

  bemStmts = bemStmt+:c -> [#stmts].concat(c),

  bemStmt = sc:sc1 bemStmtContent:c stmtContentEnd(c):se sc:sc2 -> [#stmt, sc1, c, se, sc2],

  bemStmtContent = template
    | ^stmtContent,

  // NOTE result of predRest is spliced in, hence the chained concat
  template = sc:sc1 predRest:t sc:sc2 -> [#template, [sc1].concat(t).concat([sc2])],
  subTemplate = sc:sc1 predRest:t scNoNl:sc2 -> [#sub, [sc1].concat(t).concat([sc2])],

  templateBlock = '{' subTemplate+:c sc:s '}' -> [#templateBlock, c.concat([s])],

  predicates :t = apply(t):x (',' apply(t))*:xs -> [#predicates, x].concat(xs),

  predRest = (predicates(#pred) | sc):as sc:s templateBlock:c -> [as, s, c],
  predRest = (predicates(#pred) | sc):as sc:s body:c -> [as, s, c],

  pred = (bemMatch | bemMode | bemCustom):p -> [#pred, p],

  body = ':' sc:sc1 bodyContent:bc scNoNl:sc2 ','? -> [#body, sc1, bc, sc2],

  bodyContent = asgnExpr:c (?isLiteral(c)  -> [#literalBody, c]
                            | -> [#generalBody, toStmt(toReturn(c))]
                           )
  // TODO doesn't look right. Can I match stmt here?
    | sc:sc1 stmtContent:c stmtContentEnd(c):se -> [#generalBody,  toStmt(c, se, sc1)],

  maybeLiteral :c = ,

  bemMatch = bemBlock | bemElem | bemMod,

  bemMode = sc:sc1 maybeMode:m sc:sc2 -> [m[0], sc1, [#name, m[1]], sc2],

  bemCustom = sc:sc1 asgnExpr:e sc:sc2 -> [#custom, sc1, e, sc2],

  bemBlock = bemPredic('block'):p sc:sc4 -> [#block, p.concat([sc4])],
  bemElem = bemPredic('elem'):p sc:sc4 -> [#elem, p.concat([sc4])],
  bemMod = bemPredic('mod'):p space+:s sc:sc3 bemModVal:rv sc:sc4 -> [#mod, p.concat([[#spaces, s], sc3, [#value, rv], sc4])]
    | bemPredic('elemMod'):p space+:s  sc:sc3 bemModVal:rv sc:sc4 -> [#elemMod, p.concat([[#spaces, s], sc3, [#value, rv], sc4])],

  bemPredic :n = sc:sc1 seq(n):nn space+:s sc:sc2 bemVal:lv -> [sc1, [#name, nn], [#spaces, s], sc2 , [#value, lv]],

  maybeMode = modeName:n &(spaces ('{' | ':' | ',')) -> Parser.getMode(n),

  bemVal = (letter | digit | '-')+:xs -> [#string, '\'', xs]
    | asgnExpr:e -> e,

  bemModVal = bool
    | bemVal,

  modeName = <letter (letter | digit | '-' | '_')*>:n ~isPrimitive(n) -> n,

  isPrimitive :n =  ?Parser._isPrimitive(n)
}

Parser.getMode = (function(ks, k) {
  var keywords = {};
  while(k = ks.shift()) keywords[k] = (k === 'default')? 'def': k;
  return function(k) {
    return keywords.hasOwnProperty(k)?
      ['stdMode', keywords[k]]:
      ['customMode', k];
  }
})(['tag', 'attrs', 'content', 'default', 'js', 'mix', 'bem', 'jsAttr', 'cls'])

Parser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

Parser._isPrimitive = function(name) {
  return Parser._primitives[name];
};

var DEBUG = true;

ometa Transformer <: KIdentity {
  debug :what :text = ?(DEBUG) {pp(what, {prompt: "" + text});}
    | -> true,

  topLevel = ^topLevel,

  assemble = [#predLeft :c] -> [#stmt, c.scPreCall,
                                [#exprStmt,
                                 [#callExpr, c.callee, c.scPreArgs, c.args]],
                                [ #stmtEnd, c.scPostArgs, '\n' ],
                                [ #spacesAndComments, [] ]],

  //              predicates   body|templateBlock
  template template0:t -> [#stmt,
                           t[0],
                           [#exprStmt, t[1]],
                           [#stmtEnd, t[2], '\n'],
                           [#spacesAndComments, []]],

  // TODO sc3 is pushed out during parsing in subs. Is it a good idea?
  template0 [ :sc1 t:pl :sc2 t:br (anything)?:sc3 ] debug(pl, "pl") debug(br, "br") -> {
    var l = pl[1],
        r = br[1],
        scPre = sc1[1].concat([l.scPreCall]),
        args = r.args,
        callee = [#callExpr, l.callee, l.scPreArgs, l.args],
        scPost = r.scPostBody,
        scPreArgs = sc2[1].concat([l.scPostArgs]);
    if (sc3) {
      scPost = [ #spacesAndComments, [scPost, sc3] ];
    }
    return [scPre, [#callExpr, callee, scPreArgs, args], scPost];
  },

  templateBlock = [t+:sb] -> [ #bodyRight,
                               {
                                 args: [#commaList].concat(sb),
                                 scPostBody: [ 'spacesAndComments', [] ]
                               } ],

  sub = template0:s -> [#arg].concat(s),

  // TODO generalize #predRight and #bodyRight
  body = :sc1 t:b :sc2 -> [ #bodyRight,
                            {
                              args: [#commaList, [#arg, sc1, b, [ 'spacesAndComments', [] ]]],
                              scPostBody: sc2
                            } ],

  literalBody :b -> b,
  // TODO general case into commaList
  // TODO single nested sub collapse into dot expr
  generalBody :b -> b,

  predicates = predLeft:pl predRight:pr pred+:rest predicatesPair(pl, pr):p t([#predicates].concat([p], rest)),
  predicates = predLeft:pl predRight:pr predicatesPair(pl, pr),
  predicates = predLeft,

  predicatesPair [#predLeft :pl] [#predRight :pr]
    -> [ #predLeft,
         { scPreCall: pl.scPreCall,
           callee: [ #getExprDot,
                     [#callExpr, pl.callee, pl.scPreArgs, pl.args],
                     pl.scPostArgs,
                     pr.scPostDot,
                     pr.prop ],
           scPreArgs: pr.scPreArgs,
           args: pr.args,
           scPostArgs: pr.scPostArgs } ],

  tl = [:t apply(t + #Left):l] -> l,
  tr = [:t apply(t + #Right):r] -> r,

  // { scPreCall: s, callee: ce, scPreArgs: ss, args: as, scPostArgs:sss }
  predLeft = [#predLeft anything]:pl -> pl
    | [#pred tl:r]:pl -> r,

  // { scPostDot: s, prop: p, scPreArgs: ss, args: as, scPostArgs: sss }
  predRight = [#predRight anything]:pr -> pr
    | [#pred tr:r]:pr -> r,

  pred = [#pred anything]:p -> p,

  blockLeft = bemBlockOrElemLeft,
  elemLeft = bemBlockOrElemLeft,
  stdModeLeft = :sc1 t:n :sc2 -> [ #predLeft,
                                   {
                                     scPreCall: sc1,
                                     callee: n,
                                     scPreArgs: sc2,
                                     args: [ 'spacesAndComments', [] ],
                                     scPostArgs: [ 'spacesAndComments', [] ]
                                   } ],

  customLeft = :sc1 t:n :sc2 -> [ #predLeft,
                                   {
                                     scPreCall: [ 'spacesAndComments', [] ],
                                     callee: [ 'name', 'match' ],
                                     scPreArgs: [ 'spacesAndComments', [] ],
                                     args: [#commaList, customArg(sc1, n, sc2)],
                                     scPostArgs: [ 'spacesAndComments', [] ]
                                   } ],

  customRight = :sc1 t:n :sc2 -> [ #predRight,
                                   {
                                     scPostDot: [ 'spacesAndComments', [] ],
                                     prop: [ 'name', 'match' ],
                                     scPreArgs: [ 'spacesAndComments', [] ],
                                     args: [#commaList, customArg(sc1, n, sc2)],
                                     scPostArgs: [ 'spacesAndComments', [] ]
                                   } ],

  blockRight = bemBlockOrElemRight,
  elemRight = bemBlockOrElemRight,
  stdModeRight = :sc1 t:n :sc2 -> [ #predRight,
                                    {
                                      scPostDot: sc1,
                                      prop: n,
                                      scPreArgs: sc2,
                                      args: [ 'spacesAndComments', [] ],
                                      scPostArgs: [ 'spacesAndComments', [] ]
                                    } ],

  bemBlockOrElemLeft = [:sc1 t:n [#spaces anything] :sc2 t:v :sc3] genArg(v):a
    -> [ #predLeft,
         {
           scPreCall: sc1,
           callee: n,
           scPreArgs: sc2,
           args: [#commaList, a],
           scPostArgs: sc3
         } ],

  bemBlockOrElemRight = [:sc1 t:n [#spaces anything] :sc2 t:v :sc3] genArg(v):a
    -> [ #predRight,
         {
           scPostDot: sc1,
           prop: n,
           scPreArgs: sc2,
           args: [#commaList, a],
           scPostArgs: sc3
         } ],

  genCallExpr = :name :sc1 :args -> [#callExpr, name, sc1, [#commaList].concat(args)],
  genArg :a -> [#arg, [ 'spacesAndComments', [] ], a, [ 'spacesAndComments', [] ]],

  // TODO could value be non-literal? Would need to wrap it in f()
  value t:a -> a,

}

function customArg(sc1, pred, sc2) {
  return [ 'arg',
           sc1,
           [ 'funcExpr',
             [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
             [ 'spacesAndComments', [] ],
             [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
             [ 'blockStmt',
               [ 'stmts',
                 [ 'stmt',
                   [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
                   [ 'returnStmt',
                     [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
                     pred,
                     [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ] ],
                   [ 'stmtEnd', [ 'spacesAndComments', [] ] ],
                   [ 'spacesAndComments', [] ] ] ] ] ],
           sc2 ];
}
