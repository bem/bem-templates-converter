var ometajs = require("ometajs"),
    esprima = require("esprima"),
    assert = require("assert"),
    krasota = require("krasota"),
    KParser = krasota.KrasotaJSParser,
    KIdentity = krasota.KrasotaJSIdentity,
    KSerializer = krasota.KrasotaJSSerializer;

var pp = require("zeHelpers").prettyPrint;

function toMozNode(code) {
  var mozAst = esprima.parse(code);
  var body = mozAst.body;
  assert(body.length === 1);
  return body[0].expression;
};

function isLiteral(ast) {
  // TODO exprStmt rule is unlikely to work for all cases
  try {
    // HACK to avoid extending KrasotaJSSerializer with bem-xjst non-terminals
    // like applyNext etc. When rule is missing it works but still prints to
    // stderr, see https://github.com/veged/ometa-js/issues/30
    var code = KSerializer._flatjoin(KSerializer.match(ast, 'exprStmt'));
  } catch (e) {
    return false;
  }

  if (ast[0] === ('obj')) {
    code = '(' + code + ')';
  }
  return checkLiteral(toMozNode(code));
}

function checkLiteral(ast) {
  if (ast.type === 'Literal')
    return true;

  if (ast.type === 'Identifier' && ast.name === 'undefined')
    return true;

  if (ast.type === 'ObjectExpression') {
    return ast.properties.every(function(prop) {
      return checkLiteral(prop.value);
    });
  }

  if (ast.type === 'ArrayExpression') {
    return ast.elements.every(function(elem) {
      return checkLiteral(elem);
    });
  }

  return false;
};

function toStmt(s, se, sc1, sc2) {
  return [ 'stmt',
           sc1? sc1: [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
           s,
           se? se: [ 'stmtEnd', [ 'spacesAndComments', [] ] ],
           sc2? sc2: [ 'spacesAndComments', [] ] ]
}

function toReturn(s, sc1, sc2) {
  return [ 'returnStmt',
           sc1? sc1: [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
           s,
           sc2? sc2: [ 'spacesAndComments', [] ] ]
}

ometa Parser <: KParser {

  topLevel = [(bemStmts | sc):c] -> c
    | ^topLevel,

  isXjstKeyword :x = ?(x === 'local' || x === 'apply' || x === 'applyNext' || x === 'applyCtx'),
  xjstKeyword :k = iName:kk isXjstKeyword(kk) ?(!k || k == kk) -> [#xjstKeyword, kk],

  // TODO stmt instead of a block here?
  localExpr = xjstKeyword(#local) sc:sc1 args:as sc:sc2 block:c -> [#local, sc1, as, sc2, c],
  localStmt = localExpr:e -> [#xjst, e],

  applyExpr :k = xjstKeyword(k) sc:sc1 args:as -> [k, sc1, as],
  xjst = (applyExpr(#apply)
          | applyExpr(#applyNext)
          | applyExpr(#applyCtx)
          | localExpr):e -> ([#xjst, e]),

  // NOTE adding a case to expr rule is bad idea, cause then comalist
  // expressions like (bracketed expr) with applyCtx and friends fail. This
  // needs testing but seems more solid.
  leftExpr = xjst | localStmt | callExpr | newExpr,

  stmtContent = localStmt
    | ^stmtContent,

  bemStmts = bemStmt+:c -> [#stmts].concat(c),

  bemStmt = sc:sc1 bemStmtContent:c stmtContentEnd(c):se sc:sc2 -> [#stmt, sc1, c, se, sc2],

  bemStmtContent = template
    | ^stmtContent,

  // NOTE result of predRest is spliced in, hence the chained concat
  template = sc:sc1 predRest:t -> [#template, [sc1].concat(t)],
  subTemplate = sc:sc1 predRest:t -> [#sub, [sc1].concat(t)],

  // TODO sc1 is dropped for now!!!
  templateBlock = sc:sc1 '{' subTemplate+:c sc:s '}' -> [#templateBlock, c.concat([s])],

  predicates :t = apply(t):x (',' apply(t))*:xs -> [#predicates, x].concat(xs),

  predRest = (predicates(#pred) | sc):as sc:s templateBlock:c -> [as, s, c],
  predRest = (predicates(#pred) | sc):as sc:s body:c -> [as, s, c],

  pred = (bemMatch | bemMode | bemCustom):p -> [#pred, p],

  // TODO sc1 is dropped for now!!!
  body = sc:sc1 ':' sc:sc2 bodyContent:bc ','? -> [#body, sc2, bc],

  bodyContent = asgnExpr:c (?isLiteral(c)  -> [#literalBody, c]
                            | -> [#generalBody, [#blockStmt, [#stmts, toStmt(toReturn(c))]]]
                           )
    | block:b -> ([#generalBody,  b])
    | exprStmt:s -> ([#generalBody, [#blockStmt, [#stmts, toStmt(s)]]])
    | stmt:s -> ([#generalBody, [#blockStmt, [#stmts, s]]]),

  bemMatch = bemBlock | bemElem | bemMod,

  bemMode = sc:sc1 maybeMode:m sc:sc2 -> [m[0], sc1, m[1], sc2],

  bemCustom = sc:sc1 asgnExpr:e sc:sc2 -> [#custom, sc1, e, sc2],

  bemBlock = bemPredic('block'):p sc:sc4 -> [#block, p.concat([sc4])],
  bemElem = bemPredic('elem'):p sc:sc4 -> [#elem, p.concat([sc4])],
  bemMod = bemPredic('mod'):p space+:s sc:sc3 bemModVal:rv sc:sc4 -> [#mod, p.concat([[#spaces, s], sc3, [#value, rv], sc4])]
    | bemPredic('elemMod'):p space+:s  sc:sc3 bemModVal:rv sc:sc4 -> [#elemMod, p.concat([[#spaces, s], sc3, [#value, rv], sc4])],

  bemPredic :n = sc:sc1 seq(n):nn space+:s sc:sc2 bemVal:lv -> [sc1, [#name, nn], [#spaces, s], sc2 , [#value, lv]],

  maybeMode = modeName:n &(spaces ('{' | ':' | ',')) -> Parser.getMode(n, KParser.matchAll("'" + n + "'", "string")),

  bemVal = (letter | digit | '-')+:xs -> [#string, '\'', xs]
    | asgnExpr:e -> e,

  bemModVal = bool
    | bemVal,

  modeName = <letter (letter | digit | '-' | '_')*>:n ~isPrimitive(n) -> n,

  isPrimitive :n =  ?Parser._isPrimitive(n)
}

Parser.getMode = (function(ks, k) {
  var keywords = {};
  while(k = ks.shift()) keywords[k] = (k === 'default')? 'def': k;
  return function(k, kstr) {
    return keywords.hasOwnProperty(k)?
      ['stdMode', [#name, keywords[k]]]:
      ['customMode', kstr];
  }
})(['tag', 'attrs', 'content', 'default', 'js', 'mix', 'bem', 'jsAttr', 'cls'])

Parser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

Parser._isPrimitive = function(name) {
  return Parser._primitives[name];
};


ometa Binding <: KIdentity {
  lhsThis [ #keyword #this ],
  whenThis = [ #this :n ] -> n,
  whenGet = [#getExprDot anything*]:g -> {
    var s = KSerializer._flatjoin(KSerializer.match(g, "t"));
    return KParser.matchAll("'" + s + "'", "string");
  },
  getExprDot = lhsThis :s1 :s2 :n ->  {
    this._scs.push(s1, s2);
    return [ #this, n ];
  },
  getExprDot = t:e whenThis(e)?:en :s1 :s2 :n -> {
    this._scs.push(s1, s2);
    return [#getExprDot, en? en: e, [ 'spacesAndComments', [] ], [ 'spacesAndComments', [] ], n];
  },

  binding %(this._scs = []) = [t:e :sc1 :sc2 :val]
  (whenThis(e) | whenGet(e)):b -> [ #objItem,
                                    [ 'spacesAndComments', this._scs ],
                                    b,
                                    sc1,
                                    sc2,
                                    val,
                                    [ 'spacesAndComments', [] ] ]
}

function transformApplyArgs(as) {
  var strArg = [],
      scBefore = [],
      scAfter = [],
      objItems = [],
      objArg = [];

  function pushItems(ar) {
    // skip commaList tag in the front
    for(var i = 1; i < ar.length; i++) {
      objItems.push(ar[i]);
    }
  };

  as.forEach(function (e) {
    if (e[0] === 'objArg') {
      scBefore.push(e[1]);
      pushItems(e[2][1]);
      scAfter.push(e[3]);
      return;
    }

    if (e[0] === 'strArg') {
      strArg.push(['arg', e[1], e[2], e[3]]);
      return;
    }

    if (e[0] === 'asgnArg') {
      scBefore.push(e[1]);
      objItems.push(e[2]);
      scAfter.push(e[3]);
      return;
    }

    throw("unexpected argument to apply*()");
  })

  if (objItems.length) {
    objArg.push(
      ['arg',
       ['spacesAndComments', scBefore],
       ['obj', ['commaList'].concat(objItems)],
       ['spacesAndComments', scAfter]]);
  }

  return ['commaList'].concat(strArg, objArg);
};

var DEBUG = true;

// TODO don't forget to invoke it before the Transformer grammar
ometa CollapseSub <: KIdentity {
  topLevel = ^topLevel,
  // named t e.g. tn(spaces)
  tn :rule = [:t ?(t === rule) apply(rule):r] -> r,

  template template0:t0 -> [#template, t0],

  template0 [ :sc1 t:ps :sc2 t:b ] (splice(sc1, ps, sc2, b):tp -> tp
                                    | -> [sc1, ps, sc2, b]),

  splice :sc1 :ps :sc2 [#splice [:scm1 [#predicates pred+:psm] :scm2 :bm] :scPost]
    -> [ [#spacesAndComments, [sc1, scm1]],
         ps.concat(psm),
         [#spacesAndComments, [sc2, scm2, scPost]],
         bm ],

  templateBlock = [sub:s tn(#spacesAndComments):scPost] -> [#splice, s[1], scPost],
  templateBlock = [sub+:sb tn(#spacesAndComments):scPost] -> [#templateBlock, sb.concat([scPost])],

  sub = [#sub template0:t0] -> [#sub, t0],

  body = :sc1 :b -> [#body, sc1, b],
  predicates = pred+:ps -> [#predicates].concat(ps),
  pred = [#pred anything]:p -> p
}

ometa Transformer <: KIdentity {
  debug :what :text = ?(DEBUG) {pp(what, {prompt: "" + text});}
    | -> true,

  topLevel = ^topLevel,

  // named t e.g. tn(spaces)
  tn :rule = [:t ?(t === rule) apply(rule):r] -> r,
  // accumulate spaces and comments
  scs = (tn(#spaces) | tn(#spacesAndComments))*:ss -> [ 'spacesAndComments', ss ],

  assemble = [#predLeft :c] -> [#stmt, c.scPreCall,
                                [#exprStmt,
                                 [#callExpr, c.callee, c.scPreArgs, c.args]],
                                [ #stmtEnd, c.scPostArgs, '\n' ],
                                [ #spacesAndComments, [] ]],

  //              predicates   body|templateBlock
  template template0:t -> [#stmt,
                           t[0],
                           [#exprStmt, t[1]],
                           [#stmtEnd, t[2], '\n'],
                           [#spacesAndComments, []]],

  // TODO sc3 is pushed out during parsing in subs. Is it a good idea?
  template0 [ :sc1 t:pl :sc2 t:br ] -> {
    var l = pl[1],
        r = br[1],
        scPre = [ #spacesAndComments, sc1[1].concat([l.scPreCall])],
        args = r.args,
        callee = [#callExpr, l.callee, l.scPreArgs, l.args],
        scPost = r.scPostBody,
        scPreArgs = [ #spacesAndComments, sc2[1].concat([l.scPostArgs])];
    // if (sc3) {
    //   scPost = [ #spacesAndComments, [scPost, sc3] ];
    // }
    return [scPre, [#callExpr, callee, scPreArgs, args], scPost];
  },

  templateBlock = [sub+:sb :scPost] -> [ #bodyRight,
                                         {
                                           args: [#commaList].concat(sb),
                                           scPostBody: scPost
                                         } ],

  sub = [#sub template0:s] -> [#arg].concat(s),

  // TODO generalize #predRight and #bodyRight
  body = :sc1 t:b -> [ #bodyRight,
                            {
                              args: [#commaList, [#arg, sc1, b, [ 'spacesAndComments', [] ]]],
                              scPostBody: [ 'spacesAndComments', [] ]
                            } ],

  literalBody :b -> b,

  generalBody t:rb maybeReturnLast(rb):b -> wrapBody(b),

  // return apply* in the last stmt position
  maybeReturnLast [#blockStmt [#stmts (anything+):ss]] returnLast(ss):sl -> ([#blockStmt, [#stmts].concat(sl)]),
  returnLast reverse:rss splitReturnLast(rss),
  splitReturnLast [:s (anything*):rst] returnIfApply(s):ls reverse(rst):result -> (result.concat([ls])),
  returnIfApply [#stmt :sc1 :a isApply(a) :se :sc2] -> (toStmt(toReturn(a), se, sc1, sc2)),
  returnIfApply :s -> s,
  isApply [#exprStmt [#callExpr [#name (#applyCtx | #applyNext | #apply)] anything*]],

  // reverse array ometa-style
  reverse [] -> [],
  reverse [:e] -> [e],
  reverse [:e (anything+):es] reverse(es):res -> (res.concat([e])),

  // TODO refactor into one rule and parse args into an objarg
  xjst = ([#applyCtx :sc1 :args] -> [#callExpr, [#name, #applyCtx], sc1, args]
          | [#apply :sc1 applyArgs:args] -> [#callExpr, [#name, #apply], sc1, args]
          | [#applyNext :sc1 applyArgs:args] -> [#callExpr, [#name, #applyNext], sc1, args]
          | [#local :sc1 applyArgs:args :sc2 t:b] -> [#callExpr, [#callExpr, [#name, #local], sc1, args], sc2, wrapBody(b)]
         ),

  applyArgs = [#commaList applyArg+:as] -> (transformApplyArgs(as)),
  applyArgs :as -> as,

  applyArg = [#arg :sc1 (asgnArg | strArg | objArg):a :sc2] -> [a[0], sc1, a[1], sc2],

  asgnArg = [ #binop :prop [#op :sc1 '=' :sc2] :val ] -> [#asgnArg, Binding.match([prop, sc1, sc2, val], "binding")],
  strArg = [#string :sep :v]:s -> [#strArg, s],
  objArg = [#obj anything]:o -> [#objArg, o],

  predicates = predLeft:pl predRight:pr pred+:rest predicatesPair(pl, pr):p t([#predicates].concat([p], rest)),
  predicates = predLeft:pl predRight:pr predicatesPair(pl, pr),
  predicates = predLeft,

  predicatesPair [#predLeft :pl] [#predRight :pr]
    -> [ #predLeft,
         { scPreCall: pl.scPreCall,
           callee: [ #getExprDot,
                     [#callExpr, pl.callee, pl.scPreArgs, pl.args],
                     pl.scPostArgs,
                     pr.scPostDot,
                     pr.prop ],
           scPreArgs: pr.scPreArgs,
           args: pr.args,
           scPostArgs: pr.scPostArgs } ],

  tl = [:t apply(t + #Left):l] -> l,
  tr = [:t apply(t + #Right):r] -> r,

  // { scPreCall: s, callee: ce, scPreArgs: ss, args: as, scPostArgs:sss }
  predLeft = [#predLeft anything]:pl -> pl
    | [#pred tl:r]:pl -> r,

  // { scPostDot: s, prop: p, scPreArgs: ss, args: as, scPostArgs: sss }
  predRight = [#predRight anything]:pr -> pr
    | [#pred tr:r]:pr -> r,

  pred = [#pred anything]:p -> p,

  blockLeft = bemBlockOrElemLeft,
  elemLeft = bemBlockOrElemLeft,
  stdModeLeft = :sc1 t:n :sc2 -> [ #predLeft,
                                   {
                                     scPreCall: sc1,
                                     callee: n,
                                     scPreArgs: sc2,
                                     args: [ 'spacesAndComments', [] ],
                                     scPostArgs: [ 'spacesAndComments', [] ]
                                   } ],

  customLeft = :sc1 t:n :sc2 -> [ #predLeft,
                                   {
                                     scPreCall: [ 'spacesAndComments', [] ],
                                     callee: [ 'name', 'match' ],
                                     scPreArgs: [ 'spacesAndComments', [] ],
                                     args: [#commaList, customArg(sc1, n, sc2)],
                                     scPostArgs: [ 'spacesAndComments', [] ]
                                   } ],
  customModeLeft = :sc1 :n :sc2 -> [ #predLeft,
                                   {
                                     scPreCall: sc1,
                                     callee: [ 'name', 'mode' ],
                                     scPreArgs: sc2,
                                     args: [#commaList, [ 'arg',
                                                          [ 'spacesAndComments', [] ],
                                                          n,
                                                          [ 'spacesAndComments', [] ] ]],
                                     scPostArgs: [ 'spacesAndComments', [] ]
                                   } ],
  modLeft = [:sc1 :n scs:sc2 t:m scs:sc3 t:v :sc4] -> [ #predLeft,
                                                      {
                                                        scPreCall: sc1,
                                                        callee: n,
                                                        scPreArgs: [ 'spacesAndComments', [] ],
                                                        args: [#commaList,
                                                               [ 'arg',
                                                                 [ 'spacesAndComments', [] ],
                                                                 m,
                                                                 sc2 ],
                                                               [ 'arg',
                                                                 [ 'spacesAndComments', [] ],
                                                                 v,
                                                                 sc3 ]],
                                                        scPostArgs: sc4
                                                      } ],
  modRight = [:sc1 :n scs:sc2 t:m scs:sc3 t:v :sc4] -> [ #predRight,
                                                       {
                                                         scPostDot: sc1,
                                                         prop: n,
                                                         scPreArgs: [ 'spacesAndComments', [] ],
                                                         args: [#commaList,
                                                                [ 'arg',
                                                                  [ 'spacesAndComments', [] ],
                                                                  m,
                                                                  sc2 ],
                                                                [ 'arg',
                                                                  [ 'spacesAndComments', [] ],
                                                                  v,
                                                                  sc3 ]],
                                                         scPostArgs: sc4
                                                       } ],
  elemModLeft = [:sc1 :n scs:sc2 t:m scs:sc3 t:v :sc4] -> [ #predLeft,
                                                      {
                                                        scPreCall: sc1,
                                                        callee: n,
                                                        scPreArgs: [ 'spacesAndComments', [] ],
                                                        args: [#commaList,
                                                               [ 'arg',
                                                                 [ 'spacesAndComments', [] ],
                                                                 m,
                                                                 sc2 ],
                                                               [ 'arg',
                                                                 [ 'spacesAndComments', [] ],
                                                                 v,
                                                                 sc3 ]],
                                                        scPostArgs: sc4
                                                      } ],
  elemModRight = [:sc1 :n scs:sc2 t:m scs:sc3 t:v :sc4] -> [ #predRight,
                                                       {
                                                         scPostDot: sc1,
                                                         prop: n,
                                                         scPreArgs: [ 'spacesAndComments', [] ],
                                                         args: [#commaList,
                                                                [ 'arg',
                                                                  [ 'spacesAndComments', [] ],
                                                                  m,
                                                                  sc2 ],
                                                                [ 'arg',
                                                                  [ 'spacesAndComments', [] ],
                                                                  v,
                                                                  sc3 ]],
                                                         scPostArgs: sc4
                                                       } ],
  customModeRight = :sc1 :n :sc2 -> [ #predRight,
                                      {
                                        scPostDot: sc1,
                                        prop: [ 'name', 'mode' ],
                                        scPreArgs: sc2,
                                        args: [#commaList, [ 'arg',
                                                             [ 'spacesAndComments', [] ],
                                                             n,
                                                             [ 'spacesAndComments', [] ] ]],
                                        scPostArgs: [ 'spacesAndComments', [] ]
                                      } ],

  customRight = :sc1 t:n :sc2 -> [ #predRight,
                                   {
                                     scPostDot: [ 'spacesAndComments', [] ],
                                     prop: [ 'name', 'match' ],
                                     scPreArgs: [ 'spacesAndComments', [] ],
                                     args: [#commaList, customArg(sc1, n, sc2)],
                                     scPostArgs: [ 'spacesAndComments', [] ]
                                   } ],

  blockRight = bemBlockOrElemRight,
  elemRight = bemBlockOrElemRight,
  stdModeRight = :sc1 t:n :sc2 -> [ #predRight,
                                    {
                                      scPostDot: sc1,
                                      prop: n,
                                      scPreArgs: sc2,
                                      args: [ 'spacesAndComments', [] ],
                                      scPostArgs: [ 'spacesAndComments', [] ]
                                    } ],

  bemBlockOrElemLeft = [:sc1 t:n [#spaces anything] :sc2 t:v :sc3] genArg(v):a
    -> [ #predLeft,
         {
           scPreCall: sc1,
           callee: n,
           scPreArgs: sc2,
           args: [#commaList, a],
           scPostArgs: sc3
         } ],

  bemBlockOrElemRight = [:sc1 t:n [#spaces anything] :sc2 t:v :sc3] genArg(v):a
    -> [ #predRight,
         {
           scPostDot: sc1,
           prop: n,
           scPreArgs: sc2,
           args: [#commaList, a],
           scPostArgs: sc3
         } ],

  genCallExpr = :name :sc1 :args -> [#callExpr, name, sc1, [#commaList].concat(args)],
  genArg :a -> [#arg, [ 'spacesAndComments', [] ], a, [ 'spacesAndComments', [] ]],

  // TODO could value be non-literal? Would need to wrap it in f()
  value t:a -> a
}

function customArg(sc1, pred, sc2) {
  return [ 'arg',
           sc1,
           [ 'funcExpr',
             [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
             [ 'spacesAndComments', [] ],
             [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
             [ 'blockStmt',
               [ 'stmts',
                 [ 'stmt',
                   [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
                   [ 'returnStmt',
                     [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
                     pred,
                     [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ] ],
                   [ 'stmtEnd', [ 'spacesAndComments', [] ] ],
                   [ 'spacesAndComments', [] ] ] ] ] ],
           sc2 ];
}

function wrapBody(body) {
  return [ 'funcExpr',
           [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
           [ 'spacesAndComments', [] ],
           [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
           body ];
}

ometa Serializer <: KSerializer {
  topLevel = ^topLevel
}
