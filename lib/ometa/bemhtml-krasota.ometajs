var ometajs = require("ometajs"),
    esprima = require("esprima"),
    assert = require("assert"),
    krasota = require("krasota"),
    KParser = krasota.KrasotaJSParser,
    KIdentity = krasota.KrasotaJSIdentity,
    KSerializer = krasota.KrasotaJSSerializer;

var pp = require("zeHelpers").prettyPrint;

function toMozNode(code) {
  var mozAst = esprima.parse(code);
  var body = mozAst.body;
  assert(body.length === 1);
  return body[0].expression;
};

function isLiteral(ast) {
  // TODO exprStmt rule is unlikely to work for all cases
  try {
    // HACK to avoid extending KrasotaJSSerializer with bem-xjst non-terminals
    // like applyNext etc. When rule is missing it works but still prints to
    // stderr, see https://github.com/veged/ometa-js/issues/30
    var code = KSerializer._flatjoin(KSerializer.match(ast, 'exprStmt'));
  } catch (e) {
    return false;
  }

  if (ast[0] === ('obj')) {
    code = '(' + code + ')';
  }
  return checkLiteral(toMozNode(code));
}

function checkLiteral(ast) {
  if (ast.type === 'Literal')
    return true;

  if (ast.type === 'Identifier' && ast.name === 'undefined')
    return true;

  if (ast.type === 'ObjectExpression') {
    return ast.properties.every(function(prop) {
      return checkLiteral(prop.value);
    });
  }

  if (ast.type === 'ArrayExpression') {
    return ast.elements.every(function(elem) {
      return checkLiteral(elem);
    });
  }

  return false;
};

ometa Parser <: KParser {

  topLevel = [(bemStmts | sc):c] -> c
    | ^topLevel,

  isXjstKeyword :x = ?(x === 'local' || x === 'apply' || x === 'applyNext' || x === 'applyCtx'),
  xjstKeyword :k = iName:kk isXjstKeyword(kk) ?(!k || k == kk) -> [#xjstKeyword, kk],

  localStmt = xjstKeyword(#local) sc:sc1 args:as sc:sc2 block:c -> [#local, sc1, as, sc2, c],

  applyExpr :k = xjstKeyword(k) sc:sc1 args:as sc:sc2 -> [k, sc1, as, sc2],
  xjstApply = applyExpr(#apply)
    | applyExpr(#applyNext)
    | applyExpr(#applyCtx),

  // NOTE adding a case to expr rule is bad idea, cause then comalist
  // expressions like (bracketed expr) with applyCtx and friends fail. This
  // needs testing but seems more solid.
  leftExpr = xjstApply | callExpr | newExpr,

  stmtContent = localStmt
    | ^stmtContent,

  bemStmts = bemStmt+:c -> [#stmts].concat(c),

  bemStmt = sc:sc1 bemStmtContent:c stmtContentEnd(c):se sc:sc2 -> [#stmt, sc1, c, se, sc2],

  bemStmtContent = template
    | ^stmtContent,

  // NOTE result of predRest is spliced in, hence the chained concat
  template = sc:sc1 predRest:t sc:sc2 -> [#template, [sc1].concat(t).concat([sc2])],
  subTemplate = sc:sc1 predRest:t scNoNl:sc2 -> [#sub, [sc1].concat(t).concat([sc2])],

  templateBlock = '{' subTemplate+:c sc:s '}' -> [#templateBlock, c.concat([s])],

  predicates :t = apply(t):x (',' apply(t))*:xs -> [#predicates, x].concat(xs),

  predRest = (predicates(#pred) | sc):as sc:s templateBlock:c -> [as, s, c],
  predRest = (predicates(#pred) | sc):as sc:s body:c -> [as, s, c],

  pred = (bemMatch | bemMode | bemCustom):p -> [#pred, p],

  body = ':' sc:sc1 bodyContent:bc scNoNl:sc2 ','? -> [#body, sc1, bc, sc2],

  // TODO literal check is busted, needs thorough testing and maybe a fix
  bodyContent = asgnExpr:c maybeLiteral(c):bc -> [#literalBody,  bc]
  // TODO another case here when asgnExpr succeeds but literal check fails
  // (example: obj-literal with cumputed content)
    | sc:sc1 stmtContent:c stmtContentEnd(c):se -> [#generalBody,  [#stmt, sc1, c, se]],

  maybeLiteral :c = ?(isLiteral(c)) -> c,

  bemMatch = bemBlock | bemElem | bemMod,

  bemMode = sc:sc1 maybeMode:m sc:sc2 -> [m[0], sc1, [#name, m[1]], sc2],

  bemCustom = sc:sc1 asgnExpr:e sc:sc2 -> [#custom, sc1, e, sc2],

  bemBlock = bemPredic('block'):p -> [#block, p],
  bemElem = bemPredic('elem'):p -> [#elem, p],
  bemMod = bemPredic('mod'):p bemModVal:rv sc:sc4 -> [#mod, p.concat([[#value, rv], sc4])],
    | bemPredic('elemMod'):p bemModVal:rv sc:sc4 -> [#elemMod, p.concat([[#value, rv], sc4])],

  bemPredic :n = sc:sc1 seq(n):nn sc:sc2 bemVal:lv sc:sc3 -> [sc1, [#name, nn], sc2, [#value, lv], sc3],

  maybeMode = modeName:n &(spaces ('{' | ':' | ',')) -> Parser.getMode(n),

  bemVal = (letter | digit | '-')+:xs -> [#string, xs.join('')]
    | asgnExpr:e -> e,

  bemModVal = bool
    | iName
    | bemVal,

  modeName = <letter (letter | digit | '-' | '_')*>:n ~isPrimitive(n) -> n,

  isPrimitive :n =  ?Parser._isPrimitive(n)
}

Parser.getMode = (function(ks, k) {
  var keywords = {};
  while(k = ks.shift()) keywords[k] = (k === 'default')? 'def': k;
  return function(k) {
    return keywords.hasOwnProperty(k)?
      ['stdMode', keywords[k]]:
      ['customMode', k];
  }
})(['tag', 'attrs', 'content', 'default', 'js', 'mix', 'bem', 'jsAttr', 'cls'])

Parser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

Parser._isPrimitive = function(name) {
  return Parser._primitives[name];
};

ometa Transformer <: KIdentity {

  topLevel = ^topLevel,

  template [t+:ts] -> [#template].concat(ts),
  predicates t+:ps -> [#predicates].concat(ps),
  pred :pb -> [#pred, pb],
  body t:b -> b,
  literalBody :b -> [#commaList, [#arg].concat(b)],
  // TODO general case into commaList
  // TODO single nested sub collapse into dot expr
  generalBody :b -> [#commaList, [#arg].concat(b)],
  templateBlock t:sb -> [#templateBlock, sb]
}
