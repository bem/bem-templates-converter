var ometajs = require("ometajs"),
    esprima = require("esprima"),
    assert = require("assert"),
    krasota = require("krasota"),
    KParser = krasota.KrasotaJSParser,
    KIdentity = krasota.KrasotaJSIdentity,
    KSerializer = krasota.KrasotaJSSerializer;

var pp = require("zeHelpers").prettyPrint;

function toMozNode(code) {
  var mozAst = esprima.parse(code);
  var body = mozAst.body;
  assert(body.length === 1);
  return body[0].expression;
};

function isLiteral(ast) {
  // TODO exprStmt rule is unlikely to work for all cases
  try {
    // HACK to avoid extending KrasotaJSSerializer with bem-xjst non-terminals
    // like applyNext etc. When rule is missing it works but still prints to
    // stderr, see https://github.com/veged/ometa-js/issues/30
    var code = KSerializer._flatjoin(KSerializer.match(ast, 'exprStmt'));
  } catch (e) {
    return false;
  }

  if (ast[0] === ('obj')) {
    code = '(' + code + ')';
  }
  return checkLiteral(toMozNode(code));
}

function checkLiteral(ast) {
  if (ast.type === 'Literal')
    return true;

  if (ast.type === 'Identifier' && ast.name === 'undefined')
    return true;

  if (ast.type === 'ObjectExpression') {
    return ast.properties.every(function(prop) {
      return checkLiteral(prop.value);
    });
  }

  if (ast.type === 'ArrayExpression') {
    return ast.elements.every(function(elem) {
      return checkLiteral(elem);
    });
  }

  return false;
};

function toStmt(s, se, sc1, sc2) {
  return [ 'stmt',
           sc1? sc1: [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
           s,
           se? se: [ 'stmtEnd', [ 'spacesAndComments', [] ] ],
           sc2? sc2: [ 'spacesAndComments', [] ] ]
}

function toReturn(s, sc1, sc2) {
  return [ 'returnStmt',
           sc1? sc1: [ 'spacesAndComments', [ [ 'spaces', ' ' ] ] ],
           s,
           sc2? sc2: [ 'spacesAndComments', [] ] ]
}

ometa Parser <: KParser {

  topLevel = [(bemStmts | sc):c] -> c
    | ^topLevel,

  isXjstKeyword :x = ?(x === 'local' || x === 'apply' || x === 'applyNext' || x === 'applyCtx'),
  xjstKeyword :k = iName:kk isXjstKeyword(kk) ?(!k || k == kk) -> [#xjstKeyword, kk],

  // TODO stmt instead of a block here?
  localStmt = xjstKeyword(#local) sc:sc1 args:as sc:sc2 block:c -> [#local, sc1, as, sc2, c],
  localExpr = localStmt,

  applyExpr :k = xjstKeyword(k) sc:sc1 args:as -> [k, sc1, as],
  xjst = applyExpr(#apply)
    | applyExpr(#applyNext)
    | applyExpr(#applyCtx)
    | localExpr,

  // NOTE adding a case to expr rule is bad idea, cause then comalist
  // expressions like (bracketed expr) with applyCtx and friends fail. This
  // needs testing but seems more solid.
  leftExpr = xjst | localStmt | callExpr | newExpr,

  stmtContent = localStmt
    | ^stmtContent,

  bemStmts = bemStmt+:c -> [#stmts].concat(c),

  bemStmt = sc:sc1 bemStmtContent:c stmtContentEnd(c):se sc:sc2 -> [#stmt, sc1, c, se, sc2],

  bemStmtContent = template
    | ^stmtContent,

  // NOTE result of predRest is spliced in, hence the chained concat
  template = sc:sc1 predRest:t sc:sc2 -> [#template, [sc1].concat(t).concat([sc2])],
  subTemplate = sc:sc1 predRest:t scNoNl:sc2 -> [#sub, [sc1].concat(t).concat([sc2])],

  templateBlock = '{' subTemplate+:c sc:s '}' -> [#templateBlock, c.concat([s])],

  predicates :t = apply(t):x (',' apply(t))*:xs -> [#predicates, x].concat(xs),

  predRest = (predicates(#pred) | sc):as sc:s templateBlock:c -> [as, s, c],
  predRest = (predicates(#pred) | sc):as sc:s body:c -> [as, s, c],

  pred = (bemMatch | bemMode | bemCustom):p -> [#pred, p],

  body = ':' sc:sc1 bodyContent:bc scNoNl:sc2 ','? -> [#body, sc1, bc, sc2],

  bodyContent = asgnExpr:c (?isLiteral(c)  -> [#literalBody, c]
                            | -> [#generalBody, toStmt(toReturn(c))]
                           )
  // TODO doesn't look right. Can I match stmt here?
    | sc:sc1 stmtContent:c stmtContentEnd(c):se -> [#generalBody,  toStmt(c, se, sc1)],

  maybeLiteral :c = ,

  bemMatch = bemBlock | bemElem | bemMod,

  bemMode = sc:sc1 maybeMode:m sc:sc2 -> [m[0], sc1, [#name, m[1]], sc2],

  bemCustom = sc:sc1 asgnExpr:e sc:sc2 -> [#custom, sc1, e, sc2],

  bemBlock = bemPredic('block'):p sc:sc4 -> [#block, p.concat([sc4])],
  bemElem = bemPredic('elem'):p sc:sc4 -> [#elem, p.concat([sc4])],
  bemMod = bemPredic('mod'):p space+:s sc:sc3 bemModVal:rv sc:sc4 -> [#mod, p.concat([[#spaces, s], sc3, [#value, rv], sc4])]
    | bemPredic('elemMod'):p space+:s  sc:sc3 bemModVal:rv sc:sc4 -> [#elemMod, p.concat([[#spaces, s], sc3, [#value, rv], sc4])],

  bemPredic :n = sc:sc1 seq(n):nn space+:s sc:sc2 bemVal:lv -> [sc1, [#name, nn], [#spaces, s], sc2 , [#value, lv]],

  maybeMode = modeName:n &(spaces ('{' | ':' | ',')) -> Parser.getMode(n),

  bemVal = (letter | digit | '-')+:xs -> [#string, '\'', xs]
    | asgnExpr:e -> e,

  bemModVal = bool
    | bemVal,

  modeName = <letter (letter | digit | '-' | '_')*>:n ~isPrimitive(n) -> n,

  isPrimitive :n =  ?Parser._isPrimitive(n)
}

Parser.getMode = (function(ks, k) {
  var keywords = {};
  while(k = ks.shift()) keywords[k] = (k === 'default')? 'def': k;
  return function(k) {
    return keywords.hasOwnProperty(k)?
      ['stdMode', keywords[k]]:
      ['customMode', k];
  }
})(['tag', 'attrs', 'content', 'default', 'js', 'mix', 'bem', 'jsAttr', 'cls'])

Parser._primitives = {
  'true': true,
  'false': true,
  'null': true,
  'undefined': true,
  'NaN': true,
  'Infinity': true
};

Parser._isPrimitive = function(name) {
  return Parser._primitives[name];
};

ometa Transformer <: KIdentity {

  topLevel = ^topLevel,

  template [t+:ts] -> [#template].concat(ts),

  predicates t+:ps -> [#callExpr].concat(pReduce(ps)),

  pred t:p -> p,

  block = bemBlockOrElem,
  elem = bemBlockOrElem,

  bemBlockOrElem = [ [#spacesAndComments :sc1]:scb
                     t:n
                     [#spaces anything]
                     [#spacesAndComments :sc2]:scn1
                     t:v
                     [#spacesAndComments :sc3]:scn2
                   ] arg(scn1, v, scn2):a genCallExpr(n, [#spacesAndComments, []], [a]),

  genCallExpr = :name :sc1 :args -> [#callExpr, name, sc1, [#commaList].concat(args)],

  // TODO could value be non-literal? Would need to wrap it in f()
  value t:a -> a,

  body t:b -> b,

  literalBody :b -> [#commaList, [#arg].concat(b)],
  // TODO general case into commaList
  // TODO single nested sub collapse into dot expr
  generalBody :b -> [#commaList, [#arg].concat(b)],
  templateBlock t:sb -> [#templateBlock, sb]
}
